
package io.test.js;

import io.vertx.core.Vertx;
import io.vertx.core.buffer.Buffer;
import io.vertx.core.file.AsyncFile;
import io.vertx.core.file.OpenOptions;
import io.vertx.core.json.JsonObject;
import io.vertx.ext.unit.Async;
import io.vertx.ext.unit.TestContext;
import org.junit.Assert;
import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.HashMap;
import java.util.Map;

@RunWith(io.vertx.ext.unit.junit.VertxUnitRunner.class)
public class JsVerticleRedeployTest {
    private static Vertx vertx;

    @BeforeClass
    public static void setUp(TestContext context) {
        vertx = Vertx.vertx();
    }

    /**
     * A very crude example that demonstrates how a JS verticle that uses the "Person" class is redeployed
     * to get the latest changes made by a client (ex: web editor) to the person class.
     */
    @Test
    public void testHotswapVerticle(TestContext context) {
        Async async = context.async();
        String personClassPath = getClass().getResource("/Person.js").getPath();

        // Deploy the javascript verticle that is auto-generated by the web application (editor).
        vertx.deployVerticle("js:testVerticle.js", res -> {
            if (res.succeeded()) {
                final String deploymentID = res.result();

                JsonObject message = new JsonObject();
                message.put("data", new JsonObject());

                // Test sending messages to the deployed verticle.
                vertx.eventBus().send("com.test.js:100", message, res1 -> {
                    if (res1.succeeded()) {
                        JsonObject result = (JsonObject) res1.result().body();

                        Assert.assertEquals("Number of senders do not match.", 5, result.getJsonArray("senders").size());

                        // At this point the end user has made changes to one of the data types (Person) used
                        // by this verticle.
                        // The UI regenerates the javascript verticle and the changes have to be redeployed.
                        vertx.undeploy(deploymentID, res2 -> {
                            if (res2.succeeded()) {
                                OpenOptions openOptions = new OpenOptions();
                                openOptions.setTruncateExisting(true);
                                openOptions.setWrite(true);

                                vertx.fileSystem().open(personClassPath, openOptions, f -> {
                                    if (f.failed()) {
                                        context.fail();
                                    }
                                    else {
                                        // Simulate end-user changes to Person.js file.
                                        AsyncFile asyncFile = f.result();
                                        asyncFile.write(Buffer.buffer(updatePersonClass()));
                                        asyncFile.flush();
                                        asyncFile.close(c -> {
                                            if (c.failed()) {
                                                context.fail();
                                            }
                                            else {
                                                // Redeploy the verticle to pickup the changes made to Person.js file.
                                                vertx.deployVerticle("js:testVerticle.js", res3 -> {
                                                    if (res3.succeeded()) {
                                                        vertx.eventBus().send("com.test.js:200", message, res4 -> {
                                                            if (res4.succeeded()) {
                                                                async.complete();
                                                            } else {
                                                                context.fail();
                                                            }
                                                        });

                                                    }
                                                    else {
                                                        context.fail();
                                                    }
                                                });
                                            }
                                        });
                                    }
                                });
                            } else {
                                context.fail();
                            }
                        });
                    }
                    else {
                        context.fail();
                    }
                });
            }
            else {
                System.out.println(res.cause());
                context.fail();
            }
        });
    }

    private String updatePersonClass() {
        StringBuilder personClass = new StringBuilder();

        personClass.append("var Person = function() {").append("\n");
        personClass.append("    this.firstName = null;").append("\n");
        personClass.append("    this.lastName = null;").append("\n");
        personClass.append("    this.email = null;").append("\n");
        personClass.append("};").append("\n\n");

        personClass.append("Person.bye = function() {").append("\n");
        personClass.append("    return 'Bye now!';").append("\n");
        personClass.append("};").append("\n\n");

        personClass.append("module.exports = Person;");

        return personClass.toString();
    }
}